## 包装类型的好处

1. 包装类型能表达Null的语义
   - 比如数据库的查询结果可能是null，如果用基本数据类型有NPE风险
   - 又比如显示成交总额涨跌情况，如果调用的RPC服务不成功时，应该返回null，显示成-%，而不是0%
2. 集合需要包装类型，除非使用数组，或者特殊的原子类型集合
3. 泛型需要包装类型，如Result<Integer>

## 高并发时，同步调用应该去考量锁的性能损耗
1. 能用无锁数据结构，就不要用锁;
2. 能锁区块，就不要锁整个方法体;
3. 能用对象锁，就不要用类锁。


1. 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC方法。
2. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。
3. 并发修改同一记录时，避免更新丢失，需要加锁。
4. 要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。


## 下列情形，需要进行参数校验

1. 调用频次低,执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。
2. 需要极高稳定性和可用性的方法。
3. 对外提供的开放接口，不管是RPC/API/HTTP接口。 
4. 敏感权限入口。


## 下列情形，推荐放到外层进行参数校验

1. 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。
2. 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。
3. 一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所 以 DAO 的参数校验，可以省略。
4. 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。

## catch

catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。

说明:对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利 于定位问题，这是一种不负责任的表现。

正例:用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于 简单，在程序上作出分门别类的判断，并提示给用户。

捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

